from pathlib import Path

import numpy as np
from _typeshed import Incomplete
from sl_shared_assets import ZaberPositions
from ataraxis_video_system import VideoSystem
from ataraxis_data_structures import DataLogger
from ataraxis_communication_interface import MicroControllerInterface

from .tools import get_system_configuration as get_system_configuration
from ..shared_components import (
    TTLInterface as TTLInterface,
    LickInterface as LickInterface,
    ValveInterface as ValveInterface,
)

class MicroControllerInterfaces:
    """Interfaces with all Ataraxis Micro Controller (AMC) devices that control Mesoscope-VR system hardware and acquire
    non-video behavior data.

    This class interfaces with the three AMC controllers used during various runtimes: Actor, Sensor, and Encoder. The
    class exposes methods to send commands to the hardware modules managed by these microcontrollers. In turn, these
    modules control specific components of the Mesoscope-Vr system, such as rotary encoders, solenoid valves, and
    conductive lick sensors.

    Notes:
        This class is primarily intended to be used internally by the _MesoscopeExperiment and _BehaviorTraining
        classes. Our maintenance CLI (sl-maintain) is the only exception to this rule, as it directly uses this class to
        facilitate Mesoscope-VR maintenance tasks.

        Calling the initializer does not start the underlying processes. Use the start() method before issuing other
        commands to properly initialize all remote processes. This design is intentional and is used during experiment
        and training runtimes to parallelize data preprocessing for the previous session and runtime preparation for the
        following session.

    Args:
        data_logger: The initialized DataLogger instance used to log the data generated by the managed microcontrollers.
            For most runtimes, this argument is resolved by the _MesoscopeExperiment or _BehaviorTraining classes that
            initialize this class.

    Attributes:
        _started: Tracks whether the VR system and experiment runtime are currently running.
        _system_configuration: Stores the configuration parameters used by the Mesoscope-VR system.
        _sensor_polling_delay: Stores the delay, in microseconds, between any two consecutive sensor readout polls. This
            delay is the same for most sensor modules.
        _previous_volume: Tracks the volume of water dispensed during previous deliver_reward() calls.
        _previous_tone_duration: Tracks the auditory tone duration during previous deliver_reward() or simulate_reward()
            calls.
        _lick_monitoring: Tracks the current lick monitoring state.
        _delay_timer: Stores a millisecond-precise timer used by certain sequential command methods.
        valve: The interface that controls the solenoid water valve that delivers water to the animal.
        _actor: The main interface for the 'Actor' Ataraxis Micro Controller (AMC) device.
        lick: The interface that monitors animal's interactions with the lick sensor (detects licks).
    """

    _started: bool
    _system_configuration: Incomplete
    _sensor_polling_delay: float
    _previous_volume: float
    _previous_tone_duration: int
    _frame_monitoring: bool
    _lick_monitoring: bool
    _delay_timer: Incomplete
    valve: Incomplete
    screens: Incomplete
    lick: LickInterface
    def __init__(self, data_logger: DataLogger) -> None: ...
    def __del__(self) -> None:
        """Ensures that all hardware resources are released when the object is garbage-collected."""
    def start(self) -> None:
        """Starts MicroController communication processes and configures all hardware modules to use the runtime
        parameters loaded from the acquisition system configuration file.

        This method sets up the necessary assets that enable MicroController-PC communication. Until this method is
        called, all other class methods will not function correctly.

        Notes:
            After calling this method, most hardware modules will be initialized to an idle state. The only exception to
            this rule is the wheel break, which initializes to the 'engaged' state. Use other class methods to
            switch individual hardware modules into the desired state.

            Since most modules initialize to an idle state, they will not be generating data. Therefore, it is safe
            to call this method before enabling the DataLogger class. However, it is strongly advised to enable the
            DataLogger as soon as possible to avoid data piling up in the buffer.
        """
    def stop(self) -> None:
        """Stops all MicroController communication processes and releases all resources.

        This method needs to be called at the end of each runtime to release the resources reserved by the start()
        method. Until the stop() method is called, the DataLogger instance may receive data from running
        MicroControllers, so calling this method also guarantees no MicroController data will be lost if the DataLogger
        process is terminated.
        """
    def enable_lick_monitoring(self) -> None:
        """Enables monitoring the state of the conductive lick sensor at ~ 1 kHZ rate.

        The lick sensor measures the voltage across the lick sensor and reports surges in voltage to the PC as a
        reliable proxy for tongue-to-sensor contact. Most lick events span at least 100 ms of time and, therefore, the
        rate of 1 kHZ is adequate for resolving all expected single-lick events.
        """
    def disable_lick_monitoring(self) -> None:
        """Stops monitoring the conductive lick sensor."""
    def open_valve(self) -> None:
        """Opens the water reward solenoid valve.

        This method is primarily used to prime the water line with water before the first experiment or training session
        of the day.
        """
    def close_valve(self) -> None:
        """Closes the water reward solenoid valve."""
    def deliver_reward(self, volume: float = 5.0, tone_duration: int = 300, ignore_parameters: bool = False) -> None:
        """Pulses the water reward solenoid valve for the duration of time necessary to deliver the provided volume of
        water.

        This method assumes that the valve has been calibrated before calling this method. It uses the calibration data
        provided at class instantiation to determine the period of time the valve should be kept open to deliver the
        requested volume of water.

        Args:
            volume: The volume of water to deliver, in microliters.
            tone_duration: The duration of the auditory tone, in milliseconds, to emit while delivering the water
                reward.
            ignore_parameters: Determines whether to ignore the volume and tone_duration arguments. Calling the method
                with this argument ensures that the delivered reward always uses the same volume and tone_duration as
                the previous reward command. Primarily, this argument is used when receiving reward commands from Unity.
        """
    def configure_reward_parameters(self, volume: float = 5.0, tone_duration: int = 300) -> None:
        """Configures all future water rewards to use the provided volume and tone duration parameters.

        Primarily, this function is used to reconfigure the system from GUI and trigger reward delivery from Unity.

        Args:
            volume: The volume of water to deliver, in microliters.
            tone_duration: The duration of the auditory tone, in milliseconds, to emit while delivering the water
                reward.
        """
    def reference_valve(self) -> None:
        """Runs the reference valve calibration procedure.

        Reference calibration is functionally similar to the calibrate_valve() method runtime. It is, however, optimized
        to deliver the overall volume of water recognizable for the human eye looking at the syringe holding the water
        (water 'tank' used in our system). Additionally, this uses the 5 uL volume as the reference volume, which
        matches the volume we use during experiments and training sessions.

        The reference calibration HAS to be run with the water line being primed, deaerated, and the holding ('tank')
        syringe filled exactly to the 5 mL mark. This procedure is designed to dispense 5 uL of water 200 times, which
        should overall dispense ~ 1 ml of water.
        """
    def calibrate_valve(self, pulse_duration: int = 15) -> None:
        """Cycles solenoid valve opening and closing 500 times to determine the amount of water dispensed by the input
        pulse_duration.

        The valve is kept open for the specified number of milliseconds. Between pulses, the valve is kept closed for
        300 ms. Due to our valve design, keeping the valve closed for less than 200-300 ms generates a large pressure
        at the third (Normally Open) port, which puts unnecessary strain on the port plug and internal mechanism of the
        valve.

        Notes:
            The calibration should be run with the following durations: 15 ms, 30 ms, 45 ms, and 60 ms. During testing,
            we found that these values cover the water reward range from 2 uL to 10 uL, which is enough to cover most
            training and experiment runtimes.

            Make sure that the water line is primed, deaerated, and the holding ('tank') syringe filled exactly to the
            5 mL mark at the beginning of each calibration cycle. Depending on the calibrated pulse_duration, you may
            need to refill the syringe during the calibration runtime.

        Args:
            pulse_duration: The duration, in milliseconds, the valve is kept open at each calibration cycle
        """
    @property
    def delivered_water_volume(self) -> np.float64:
        """Returns the total volume of water, in microliters, dispensed by the valve since runtime onset."""
    @property
    def lick_count(self) -> np.uint64:
        """Returns the total number of licks recorded since runtime onset."""

class VideoSystems:
    """Interfaces with all cameras managed by Ataraxis Video System (AVS) classes that acquire and save camera frames
    as .mp4 video files.

    This class interfaces with the three AVS cameras used during various runtimes to record animal behavior: the face
    camera and the two body cameras (the left camera and the right camera). The face camera is a high-grade scientific
    camera that records the animal's face and pupil. The left and right cameras are lower-end security cameras recording
    the animal's body from the left and right sides.

    Notes:
        This class is primarily intended to be used internally by the _MesoscopeExperiment and _BehaviorTraining
        classes. Do not initialize this class directly unless you know what you are doing.

        Calling the initializer does not start the underlying processes. Call the appropriate start() method to start
        acquiring and displaying face and body camera frames (there is a separate method for these two groups). Call
        the appropriate save() method to start saving the acquired frames to video files. Note that there is a single
        'global' stop() method that works for all cameras at the same time.

        The class is designed to be 'lock-in'. Once a camera is enabled, the only way to disable frame acquisition is to
        call the main stop() method. Similarly, once frame saving is started, there is no way to disable it without
        stopping the whole class. This is an intentional design decision optimized to the specific class use-pattern in
        our lab.

    Args:
        data_logger: The initialized DataLogger instance used to log the data generated by the managed cameras. For most
            runtimes, this argument is resolved by the _MesoscopeExperiment or _BehaviorTraining classes that
            initialize this class.
        output_directory: The path to the directory where to output the generated .mp4 video files. Each managed camera
            generates a separate video file saved in the provided directory. For most runtimes, this argument is
            resolved by the _MesoscopeExperiment or _BehaviorTraining classes that initialize this class.

    Attributes:
        _face_camera_started: Tracks whether the face camera frame acquisition is running.
        _body_cameras_started: Tracks whether the body cameras frame acquisition is running.
        _system_configuration: Stores the configuration parameters used by the Mesoscope-VR system.
        _face-camera: The interface that captures and saves the frames acquired by the 9MP scientific camera aimed at
            the animal's face and eye from the left side (via a hot mirror).
        _left_camera: The interface that captures and saves the frames acquired by the 1080P security camera aimed on
            the left side of the animal and the right and center VR screens.
        _right_camera: The interface that captures and saves the frames acquired by the 1080P security camera aimed on
            the right side of the animal and the left VR screen.
    """

    _face_camera_started: bool
    _body_cameras_started: bool
    _system_configuration: Incomplete
    _face_camera: VideoSystem
    _left_camera: VideoSystem
    _right_camera: VideoSystem
    def __init__(self, data_logger: DataLogger, output_directory: Path) -> None: ...
    def __del__(self) -> None:
        """Ensures all hardware resources are released when the class is garbage-collected."""
    def start_face_camera(self) -> None:
        """Starts face camera frame acquisition.

        This method sets up both the frame acquisition (producer) process and the frame saver (consumer) process.
        However, the consumer process will not save any frames until the save_face_camera_frames () method is called.
        """
    def start_body_cameras(self) -> None:
        """Starts left and right (body) camera frame acquisition.

        This method sets up both the frame acquisition (producer) process and the frame saver (consumer) process for
        both cameras. However, the consumer processes will not save any frames until the save_body_camera_frames ()
        method is called.
        """
    def save_face_camera_frames(self) -> None:
        """Starts saving the frames acquired by the face camera as a video file."""
    def save_body_camera_frames(self) -> None:
        """Starts saving the frames acquired by the left and right body cameras as a video file."""
    def stop(self) -> None:
        """Stops saving all camera frames and terminates the managed VideoSystems.

        This method needs to be called at the end of each runtime to release the resources reserved by the start()
        methods. Until the stop() method is called, the DataLogger instance may receive data from running
        VideoSystems, so calling this method also guarantees no VideoSystem data will be lost if the DataLogger
        process is terminated. Similarly, this guarantees the integrity of the generated video files.
        """
    @property
    def face_camera_log_path(self) -> Path:
        """Returns the path to the compressed .npz archive that stores the data logged by the face camera during
        runtime."""
    @property
    def left_camera_log_path(self) -> Path:
        """Returns the path to the compressed .npz archive that stores the data logged by the left body camera during
        runtime."""
    @property
    def right_camera_log_path(self) -> Path:
        """Returns the path to the compressed .npz archive that stores the data logged by the right body camera during
        runtime."""
