"""This module provides the Visualizer class, a major training and experiment runtime UI element used to provide
real-time feedback on the animal's task performance and task parameters.

Modified from the original Ataraxis Visualizer class to suit the needs of the Yapici lab. Bscially, the class is
stripped down to only visualize the lick sensor and valve states, and runs on Windows OS. (WJ)"""

import numpy as np
import matplotlib
from numpy.typing import NDArray

from ataraxis_time import PrecisionTimer
from matplotlib.axes import Axes
from matplotlib.text import Text
from matplotlib.lines import Line2D
from matplotlib.figure import Figure
import matplotlib.pyplot as plt
from matplotlib.ticker import MaxNLocator, FixedLocator, FixedFormatter
from ataraxis_base_utilities import console

# Updates plotting dictionaries to preferentially use Arial text style and specific sizes for different text elements
# in plots:
# General parameters and the font size for axes' tick numbers
plt.rcParams.update({"font.family": "Arial", "font.weight": "normal", "xtick.labelsize": 16, "ytick.labelsize": 16})
_fontdict_axis_label = {"family": "Arial", "weight": "normal", "size": 18}  # Axis label fonts
_fontdict_title = {"family": "Arial", "weight": "normal", "size": 20}  # Title fonts
_fontdict_legend = {"family": "Arial", "weight": "normal", "size": 14}  # Legend fonts

# Initializes dictionaries to map colloquial names to specific linestyle and color parameters
_line_style_dict = {"solid": "-", "dashed": "--", "dotdashed": "_.", "dotted": ":"}
_palette_dict = {
    "green": (0.000, 0.639, 0.408),
    "blue": (0.000, 0.525, 0.749),
    "red": (0.769, 0.008, 0.137),
    "yellow": (1.000, 0.827, 0.000),
    "purple": (0.549, 0.000, 0.749),
    "orange": (1.000, 0.502, 0.000),
    "pink": (0.945, 0.569, 0.608),
    "black": (0.000, 0.000, 0.000),
    "white": (1.000, 1.000, 1.000),
    "gray": (0.500, 0.500, 0.500),
}


def _plt_palette(color: str) -> tuple[float, float, float]:
    """Converts colloquial color names to pyplot RGB color codes.

    The provided colors are not perfectly colorblind-friendly. They should be used with different 'line style' formats
    to improve readability in the monochrome spectrum. The codes generated by this function should be passed to the
    'color' argument of the pyplot module.

    Args:
        color: Colloquial name of the color to be retrieved. Available options are: 'green', 'blue', 'red', 'yellow',
            'purple', 'orange', 'pink', 'black', 'white', 'gray'.

    Returns:
        A list of R, G, and B values for the requested color.

    Raises:
        KeyError: If the provided color is not recognized.
    """

    try:
        return _palette_dict[color]
    except KeyError:
        message = (
            f"Unexpected color name '{color}' encountered when converting the colloquial color name to RGB array. "
            f"Provide one of the supported color arguments: {', '.join(_palette_dict.keys())}."
        )
        console.error(message=message, error=KeyError)
        # Fallback to appease mypy, should not be reachable
        raise KeyError(message)  # pragma: no cover


def _plt_line_styles(line_style: str) -> str:
    """Converts colloquial line style names to pyplot's 'lifestyle' string-codes.

    Args:
        line_style: Colloquial name for the line style to be used. Options are 'solid', 'dashed', 'dotdashed' and
            'dotted'.

    Returns:
        The string-code for the requested line style.

    Raises:
        KeyError: If the provided line style is not recognized.
    """

    try:
        return str(_line_style_dict[line_style])
    except KeyError:
        message = (
            f"Unexpected line style name '{line_style}' encountered when converting the colloquial line style pyplot "
            f"linestyle string. Provide one of the supported line style arguments: "
            f"{', '.join(_line_style_dict.keys())}."
        )
        console.error(message=message, error=KeyError)
        # Fallback to appease mypy, should not be reachable
        raise KeyError(message)  # pragma: no cover


class BehaviorVisualizer:
    """Visualizes lick, valve, and running speed data in real time.

    This class is used to visualize the key behavioral metrics collected from animals performing experiment or training
    sessions in the YL lickometer system. Note, the class is statically configured to generate the plots for all
    supported metrics, even if some of them are not used during a particular runtime (session) type.

    Notes:
        This class is designed to run in the main thread of the runtime control process. To update the visualized data,
        call the 'update' class method as part of the runtime cycle method.

        Calling this initializer does not open the visualizer plot window. Call the open() class method to finalize
        the visualizer initialization before starting runtime.

    Attributes:
        _left_event_tick_true: Stores a NumPy uint8 value of 1 to expedite visualization data processing.
        _left_event_tick_false: Stores a NumPy uint8 value of 0 to expedite visualization data processing.
        _time_window: Specifies the time window, in seconds, to visualize during runtime. Currently, this is statically
            set to 10 seconds.
        _time_step: Specifies the interval, in milliseconds, at which to update the visualization plots. Currently, this
            is statically set to 40 milliseconds, which gives a good balance between update smoothness and rendering
            time. This time delay corresponds to the desired update frequency of ~ 25 fps.
        _update_timer: The PrecisionTimer instance used to ensure that the figure is updated once every _time_step
            milliseconds.
        _timestamps: A numpy array that stores the timestamps of the displayed data during visualization runtime. The
            timestamps are generated at class initialization and are kept constant during runtime.
        _left_lick_data: A numpy array that stores the data used to generate the lick sensor state plot.
        _left_valve_data: A numpy array that stores the data used to generate the solenoid valve state plot.
        _left_lick_event: Determines whether the runtime has detected a new lick event since the last visualizer update.
        _left_valve_event: Determines whether the runtime has detected a new valve event since the last visualizer update.
        _left_lick_line: Stores the line class used to plot the lick sensor data.
        _left_valve_line: Stores the line class used to plot the solenoid valve data.
        _figure: Stores the matplotlib figure instance used to display the plots.
        _left_lick_axis: The axis object used to plot the lick sensor data during visualization runtime.
        _left_valve_axis: The axis object used to plot the solenoid valve data during visualization runtime.
        _once: This flag is used to limit certain visualizer operations to only be called once during runtime.
        _is_open: Tracks whether the visualizer plot has been created.
    """

    # Pre-initializes NumPy event ticks to slightly reduce cyclic visualizer update speed
    _left_event_tick_true = np.uint8(1)
    _left_event_tick_false = np.uint8(0)
    _right_event_tick_true = np.uint8(1)
    _right_event_tick_false = np.uint8(0)

    def __init__(
        self,
    ) -> None:
        # Currently, the class is statically configured to visualize the sliding window of 10 seconds updated every 25
        # ms.
        self._time_window: int = 10
        self._time_step: int = 25
        self._update_timer = PrecisionTimer("ms")

        # Precreates the structures used to store the displayed data during visualization runtime
        self._timestamps: NDArray[np.float32] = np.arange(
            start=0 - self._time_window, stop=self._time_step / 1000, step=self._time_step / 1000, dtype=np.float32
        )
        self._left_lick_data: NDArray[np.uint8] = np.zeros_like(a=self._timestamps, dtype=np.uint8)
        self._left_valve_data: NDArray[np.uint8] = np.zeros_like(a=self._timestamps, dtype=np.uint8)
        self._left_valve_event: bool = False
        self._left_lick_event: bool = False

        self._right_lick_data: NDArray[np.uint8] = np.zeros_like(a=self._timestamps, dtype=np.uint8)
        self._right_valve_data: NDArray[np.uint8] = np.zeros_like(a=self._timestamps, dtype=np.uint8)
        self._right_valve_event: bool = False
        self._right_lick_event: bool = False

        # Line objects (to be created during open())
        self._left_lick_line: Line2D | None = None
        self._left_valve_line: Line2D | None = None
        self._right_lick_line: Line2D | None = None
        self._right_valve_line: Line2D | None = None

        # Figure objects (to be created during open())
        self._figure: Figure | None = None
        self._left_lick_axis: Axes | None = None
        self._left_valve_axis: Axes | None = None
        self._right_lick_axis: Axes | None = None
        self._right_valve_axis: Axes | None = None

        # Tracks if the visualizer is opened
        self._is_open: bool = False
        self._once: bool = True

    def open(self) -> None:
        """Opens the visualization window and initializes all matplotlib components.

        This method must be called before any visualization updates can occur.
        """
        if self._is_open:
            return  # Already open

        # Creates the figure with two subplots sharing the same x-axis
        self._figure, axes = plt.subplots(
            2,
            2,
            figsize=(10, 8),
            sharex=True,
            num="Runtime Behavior Visualizer",
            # Ensures that the third subplot is thrice as tall
            gridspec_kw={"hspace": 0.3, "left": 0.15, "height_ratios": [1, 1]},
        )
        self._left_lick_axis = axes[0, 0]
        self._left_valve_axis = axes[1, 0]
        self._right_lick_axis = axes[0, 1]
        self._right_valve_axis = axes[1, 1]

        # Sets consistent y-label padding for all axes
        self._left_lick_axis.yaxis.labelpad = 15
        self._left_valve_axis.yaxis.labelpad = 15
        self._right_lick_axis.yaxis.labelpad = 15
        self._right_valve_axis.yaxis.labelpad = 15

        # Set up axes properties
        # Lick axis
        self._left_lick_axis.set_title("Left Lick Sensor State", fontdict=_fontdict_title)
        self._left_lick_axis.set_ylim(-0.05, 1.05)
        self._left_lick_axis.set_ylabel("Left Lick State", fontdict=_fontdict_axis_label)
        self._left_lick_axis.set_xlabel("")
        self._left_lick_axis.yaxis.set_major_locator(FixedLocator([0, 1]))
        self._left_lick_axis.yaxis.set_major_formatter(FixedFormatter(["No Lick", "Lick"]))

        self._right_lick_axis.set_title("Right Lick Sensor State", fontdict=_fontdict_title)
        self._right_lick_axis.set_ylim(-0.05, 1.05)
        self._right_lick_axis.set_ylabel("Right Lick State", fontdict=_fontdict_axis_label)
        self._right_lick_axis.set_xlabel("")
        self._right_lick_axis.yaxis.set_major_locator(FixedLocator([0, 1]))
        self._right_lick_axis.yaxis.set_major_formatter(FixedFormatter(["No Lick", "Lick"]))

        # Valve axis
        self._left_valve_axis.set_title("Left Reward Valve State", fontdict=_fontdict_title)
        self._left_valve_axis.set_ylim(-0.05, 1.05)
        self._left_valve_axis.set_ylabel("Left Valve State", fontdict=_fontdict_axis_label)
        self._left_valve_axis.set_xlabel("")
        self._left_valve_axis.yaxis.set_major_locator(FixedLocator([0, 1]))
        self._left_valve_axis.yaxis.set_major_formatter(FixedFormatter(["Closed", "Open"]))

        self._right_valve_axis.set_title("Right Reward Valve State", fontdict=_fontdict_title)
        self._right_valve_axis.set_ylim(-0.05, 1.05)
        self._right_valve_axis.set_ylabel("Right Valve State", fontdict=_fontdict_axis_label)
        self._right_valve_axis.set_xlabel("")
        self._right_valve_axis.yaxis.set_major_locator(FixedLocator([0, 1]))
        self._right_valve_axis.yaxis.set_major_formatter(FixedFormatter(["Closed", "Open"]))

        # Sets x-limits for all axes (shared x-axis)
        self._left_valve_axis.set_xlim(-self._time_window, 0)
        self._right_valve_axis.set_xlim(-self._time_window, 0)

        # Hides x-tick labels for top plots
        plt.setp(self._left_lick_axis.get_xticklabels(), visible=False)
        plt.setp(self._right_lick_axis.get_xticklabels(), visible=False)

        # Aligns all y-labels
        self._figure.align_ylabels([self._left_lick_axis, self._left_valve_axis, self._right_lick_axis, self._right_valve_axis])

        # Creates the plot artists
        # Lick plot
        (self._left_lick_line,) = self._left_lick_axis.plot(
            self._timestamps,
            self._left_lick_data,
            drawstyle="steps-post",
            color=_plt_palette("red"),
            linewidth=2,
            alpha=1.0,
            linestyle="solid",
        )

        (self._right_lick_line,) = self._right_lick_axis.plot(
            self._timestamps,
            self._right_lick_data,
            drawstyle="steps-post",
            color=_plt_palette("red"),
            linewidth=2,
            alpha=1.0,
            linestyle="solid",
        )

        # Valve plot
        (self._left_valve_line,) = self._left_valve_axis.plot(
            self._timestamps,
            self._left_valve_data,
            drawstyle="steps-post",
            color=_plt_palette("blue"),
            linewidth=2,
            alpha=1.0,
            linestyle="solid",
        )

        (self._right_valve_line,) = self._right_valve_axis.plot(
            self._timestamps,
            self._right_valve_data,
            drawstyle="steps-post",
            color=_plt_palette("blue"),
            linewidth=2,
            alpha=1.0,
            linestyle="solid",
        )

        # Generates the figure object and updates it
        plt.show(block=False)
        self._figure.canvas.draw()
        self._figure.canvas.flush_events()

        self._is_open = True

    def __del__(self) -> None:
        """Ensures all resources are released when the figure object is garbage-collected."""
        self.close()

    def update(self) -> None:
        """Updates the figure managed by the class to display new data.

        This method discards the oldest datapoint in the plot memory and instead samples a new datapoint. It also shifts
        all datapoints one timestamp to the left. When the method is called repeatedly, this makes the plot lines
        naturally flow from the right (now) to the left (12 seconds in the past), accurately displaying the visualized
        data history.

        Notes:
            The method has an internal update frequency limiter. Therefore, to achieve optimal performance, call this
            method as frequently as possible and rely on the internal limiter to force the specific update frequency.
        """
        # Does not do anything until the figure is opened (created)
        if not self._is_open:
            return

        # Ensures the plot is not updated any faster than necessary to resolve the time-step used by the plot
        if self._update_timer.elapsed < self._time_step:
            return

        self._update_timer.reset()

        # Replaces the oldest timestamp data with the current data.
        self._sample_data()

        # Updates the artists with new data
        self._left_lick_line.set_data(self._timestamps, self._left_lick_data)  # type: ignore
        self._left_valve_line.set_data(self._timestamps, self._left_valve_data)  # type: ignore
        self._right_lick_line.set_data(self._timestamps, self._right_lick_data)  # type: ignore
        self._right_valve_line.set_data(self._timestamps, self._right_valve_data)  # type: ignore

        # Renders the changes
        self._figure.canvas.draw()  # type: ignore
        self._figure.canvas.flush_events()  # type: ignore

    def close(self) -> None:
        """Closes the visualized figure and cleans up the resources used by the class during runtime."""

        if self._is_open and self._figure is not None:
            plt.close(self._figure)
            self._is_open = False

    def _sample_data(self) -> None:
        """Updates the visualization arrays with data sent from the central runtime class before re-rendering the
        managed plots.
        """

        # Rolls arrays by one position to the left, so the first element becomes the last
        self._left_valve_data = np.roll(self._left_valve_data, shift=-1)
        self._left_lick_data = np.roll(self._left_lick_data, shift=-1)
        self._right_valve_data = np.roll(self._right_valve_data, shift=-1)
        self._right_lick_data = np.roll(self._right_lick_data, shift=-1)

        # Replaces the last element (previously the first or 'oldest' value) with new data:

        # If the runtime has detected at least one lick event since the last visualizer update, emits a lick tick.
        if self._left_lick_event:
            self._left_lick_data[-1] = self._left_event_tick_true
        else:
            self._left_lick_data[-1] = self._left_event_tick_false
        self._left_lick_event = False  # Resets the left lick event flag

        if self._right_lick_event:
            self._right_lick_data[-1] = self._right_event_tick_true
        else:
            self._right_lick_data[-1] = self._right_event_tick_false
        self._right_lick_event = False  # Resets the right lick event flag

        # If the runtime has detected at least one water reward (valve) event since the last visualizer update, emits a
        # valve activation tick.
        if self._left_valve_event:
            self._left_valve_data[-1] = self._left_event_tick_true
        else:
            self._left_valve_data[-1] = self._left_event_tick_false
        self._left_valve_event = False  # Resets the valve event flag

        if self._right_valve_event:
            self._right_valve_data[-1] = self._right_event_tick_true
        else:
            self._right_valve_data[-1] = self._right_event_tick_false
        self._right_valve_event = False  # Resets the valve event flag

    def add_left_lick_event(self) -> None:
        """Configures the visualizer to render a new lick event during the next update cycle."""
        self._left_lick_event = True

    def add_right_lick_event(self) -> None:
        """Configures the visualizer to render a new right lick event during the next update cycle."""
        self._right_lick_event = True

    def add_left_valve_event(self) -> None:
        """Configures the visualizer to render a new left valve activation event during the next update cycle."""
        self._left_valve_event = True

    def add_right_valve_event(self) -> None:
        """Configures the visualizer to render a new right valve activation event during the next update cycle."""
        self._right_valve_event = True

    @property
    def is_open(self) -> bool:
        """Returns True if the visualizer window is currently open."""
        return self._is_open
